package tto

import (
	"encoding/json"
	"fmt"
	"os"
	"regexp"
	"strings"
	"sync"
)

var predefineRegexp = regexp.MustCompilePOSIX(`#\!([^\!-]+):([^#]+?)`)
var lineJoinRegexp = regexp.MustCompile(`\s*\\(\s+)`)

// var lineJoinRegexp = regexp.MustCompile(`\\s*\\\\(\\s+)`)
var tplCommentRegexp = regexp.MustCompile(`/\*+(\s*)#!(.+?)*/`)

type TemplateKind int

const (
	// 普通模板
	KindNormal = TemplateKind(0)
	// 使用所有表生成模板
	KindTables = TemplateKind(1)
	// 按表前缀生成模板
	KindTablePrefix = TemplateKind(2)
)

type Template struct {
	path      string
	template  string
	predefine map[string]string
	kind      TemplateKind
	mux       *sync.RWMutex
}

func NewTemplate(s string, path string, attach bool) *Template {
	t := &Template{path: path, mux: &sync.RWMutex{}}
	return t.resolve(t.attach(s, attach))
}

func (g *Template) resolve(s string) *Template {
	g.mux.Lock()
	g.predefine = make(map[string]string)
	for _, match := range predefineRegexp.FindAllStringSubmatch(s, -1) {
		g.predefine[match[1]] = match[2]
	}
	g.mux.Unlock()
	g.template = g.formatContent(s)
	// 识别类型
	switch g.predefine["kind"] {
	case "1", "tables":
		g.kind = KindTables
	case "2", "prefix":
		g.kind = KindTablePrefix
	default:
		g.kind = KindNormal
	}
	return g
}

// 返回模板内容
func (g *Template) formatContent(s string) string {
	s = predefineRegexp.ReplaceAllString(s, "")
	// 去掉模板注释
	s = tplCommentRegexp.ReplaceAllString(s, "")
	// 去掉多余的换行
	s = lineJoinRegexp.ReplaceAllString(s, "")
	return s
}

func (g *Template) Kind() TemplateKind {
	return g.kind
}

// 文件路径
func (g *Template) FilePath() string {
	return g.path
}

// 获取模板内容
func (g *Template) String() string {
	return g.template
}

// 获取预定义的参数
func (g *Template) Predefine(key string) (string, bool) {
	g.mux.RLock()
	defer g.mux.RUnlock()
	n, ok := g.predefine[key]
	return n, ok
}

// attach: attach generator copyright at template file first line
func (g *Template) attach(s string, attach bool) string {
	if attach {
		l := getLangByPath(g.path)
		if l == L_Python {
			return g.python(s)
		}
		if l == L_Dart {
			return g.dart(s)
		}
		if len(s) > 1 && s[0] != '/' {
			if l != L_Unknown {
				return g.copyright(s)
			}
		}
	}
	return s
}

func (g *Template) baseContent() string {
	return `# 
# This file is auto generated by tto v` + BuildVersion + ` !
# If you want to modify this code, please read the guide  
# to modify code template.
#
# Get started: https://github.com/ixre/tto
#
# Copyright (C) 2009-{{.global.year}} {{.global.organization}}, All rights reserved.
#
# name : $file_name$
# author : {{.global.user}}
# date : {{.global.time}}
# description :
# history :
#`
}

func (g *Template) python(s string) string {
	if strings.HasPrefix(s, "#") && !strings.HasPrefix(s, "#!") {
		return s
	}
	return g.baseContent() + s
}

func (g *Template) copyright(s string) string {
	return `/**
 * This file is auto generated by tto v` + BuildVersion + ` !
 * If you want to modify this code, please read the guide 
 * to modify code template.
 *
 * Get started: https://github.com/ixre/tto
 *
 * Copyright (C) 2009-{{.global.year}} {{.global.organization}}, All rights reserved.
 *
 * name : $file_name$
 * author : {{.global.user}}
 * date : {{.global.time}}
 * description :
 * history :
 */
` + s
}

func (g *Template) dart(s string) string {
	if strings.HasPrefix(s, "///") {
		return s
	}
	return strings.Replace(g.baseContent(), "#", "///", -1) + s
}

// TemplatePackageInfo 模板包信息
type TemplatePackageInfo struct {
	// 包名
	PackageName string `json:"packageName"`
	// 模板名称
	TemplateName string `json:"templateName"`
	// 作者
	Author string `json:"author"`
	// 模板网址
	Url string `json:"url"`
	// 版本号
	Version string `json:"version"`
	// 最后更新时间
	LastUpdate string `json:"lastUpdate"`
}

// TemplatePackageJson 模板包信息配置
type TemplatePackageJson struct {
	// 模板名称
	Name string `json:"name"`
	// 模板作者
	Author string `json:"author"`
	// 模板网址
	Url string `json:"url"`
	// 版本号
	Version string `json:"version"`
	// 最后更新时间
	LastUpdate string `json:"lastUpdate"`
}

// ResolveTemplatePackage 解析模板包信息
func ResolveTemplatePackage(path string) *TemplatePackageInfo {
	pkgName := path[strings.LastIndex(path, "/")+1:]
	ret := &TemplatePackageInfo{
		PackageName:  pkgName,
		TemplateName: pkgName,
		Version:      "0.1",
		LastUpdate:   "-",
	}
	jsonPath := fmt.Sprintf("%s/%s", path, "package.json")
	bytes, err := os.ReadFile(jsonPath)
	if err == nil {
		// 获取模板包信息
		var js TemplatePackageJson
		json.Unmarshal(bytes, &js)
		ret.Author = js.Author
		ret.Url = js.Url
		ret.TemplateName = js.Name
		ret.Version = js.Version
		ret.LastUpdate = js.LastUpdate
	}
	return ret
}
